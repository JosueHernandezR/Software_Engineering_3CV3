\documentclass[12pt,twoside]{article}
\usepackage{amsmath, amssymb}
\usepackage{amsmath}
\usepackage[active]{srcltx}
\usepackage{amssymb}
\usepackage{amscd}
\usepackage{makeidx}
\usepackage{amsthm}
\usepackage{algpseudocode}
\usepackage{algorithm}
\renewcommand{\baselinestretch}{1}
\setcounter{page}{1}
\setlength{\textheight}{21.6cm}
\setlength{\textwidth}{14cm}
\setlength{\oddsidemargin}{1cm}
\setlength{\evensidemargin}{1cm}
\pagestyle{myheadings}
\thispagestyle{empty}
\markboth{\small{Josu\'e David Hern\'andez Ram\'irez}}{\small{.}}
\date{}
\begin{document}
\centerline{\bf Ingeniería de Software, Sem: 2021-1, 3CV3, Tarea 1, 30/09/2020}
\centerline{}
\centerline{}
\begin{center}
\Large{\textsc{Tarea 1: Pertinencia del temario}}
\end{center}
\centerline{}
\centerline{\bf {Josu\'e David Hern\'andez Ram\'irez.}}
\centerline{}
\centerline{Escuela Superior de C\'omputo}
\centerline{Instituto Polit\'ecnico Nacional, M\'exico}
\centerline{$jhernandezr1605@alumno.ipn.mx$}
\newtheorem{Theorem}{\quad Theorem}[section]
\newtheorem{Definition}[Theorem]{\quad Definition}
\newtheorem{Corollary}[Theorem]{\quad Corollary}
\newtheorem{Lemma}[Theorem]{\quad Lemma}
\newtheorem{Example}[Theorem]{\quad Example}
\bigskip
% \textbf{Resumen:} Redactar de manera breve y concisa de que trata el trabajo presentado. Un
% s\'olo p\'arrafo.
% {\bf Palabras Clave:} Colocar de 3 a 5 palabras clave.
\section{Temas}
\subsection{Ingenier\'ia de Software}
\subsubsection{Conceptos b\'asicos de ingenier\'ia de software.}
\textbf{¿Qu\'e es software?}\\
Programas de c\'omputo y su documentaci\'on asociada: requerimientos, modelos de diseño y 
manuales de usuario,puede ser creado desarrollando nuevos programas, configurando 
sistemas de software genérico o reutilizando software existente.\\
\textbf{¿Qu\'e es la ingenier\'ia de software?}\\
Una disciplina de la Ingeniería que concierne a todos los aspectos de la producción de 
software, utilizando las herramientas y técnicas apropiadas para resolver el problema 
planteado, de acuerdo a las restricciones de desarrollo y a los recursos disponibles.\\
\textbf{¿Qu\'e es un proceso de software?}\\
Un conjunto estructurado de actividades cuya meta es el desarrollo o evolución de un 
software.\\
Algunas actividades genéricas en todos los procesos de software son:
\begin{enumerate}
    \item Especificación: qué debe hacer el software y cuáles son sus especificaciones 
    de desarrollo.
    \item Desarrollo: producción del sistema de software Validación, verificar que el 
    software cumple con lo solicitado por el cliente.
    \item Evolución: cambiar/adaptar el software a las nuevas demandas.
\end{enumerate}
\textbf{¿Qué es un modelo de proceso de software?}\\
Representación formal y simplificada de un proceso de software, presentada desde una 
perspectiva específica.\\
Modelos Genéricos:
\begin{enumerate}
    \item Cascada, separar en distintas fases de especificación y desarrollo.
    \item Desarrollo Iterativo, la especificación, desarrollo y validación están 
    interrelacionados.
    \item Prototipo, un modelo sirve de prototipo para la construcción del sistema final.
    \item Basado en componentes, asume que partes del sistema ya existen y se enfoca a su 
    integración.
\end{enumerate}
\textbf{¿Cuáles son los costos de la ingeniería de software?}
El costo total de un software esta dividido aproximadamente de la siguiente forma:
\begin{itemize}
    \item 60\% costos de desarrollo
    \item 40\% costos de pruebas
    \item Los costos dependen del tipo de sistema que se desarrolla y de los 
    requerimientos del mismo tales como desempeño y confiabilidad, la distribución de 
    los costos depende del modelo de desarrollo empleado. 
\end{itemize}
\textbf{¿Qué es CASE?}
CASE es Computer-Aided Software Engineering son programas que son usados para dar
soporte automatizado a las actividades del proceso de software como:
\begin{itemize}
    \item Las herramientas CASE son comúnmente usadas para dar soporte a los métodos de
    software.
    \item Módulos de análisis que verifican que las reglas del método se cumplan.
    \item Generadores de reportes que facilitan la creación de la documentación del sistema
    \item Generadores de código a partir del modelo del sistema.
\end{itemize}
\subsubsection{Atributos y características del software}
\textbf{Características}
Para poder comprender lo que es el software (y consecuentemente la ingeniería del 
software), es importante examinar las características del software que lo diferencian de 
otras cosas que los humanos pueden construir.
\begin{enumerate}
    \item \textbf{El software se desarrolla, no se fabrica en un sentido clásico}.
    \item \textbf{El software no se estropea}.
    \item \textbf{Aunque la industria tiende a ensamblar componentes, la mayoría del software 
    se construye a medida}.
\end{enumerate}
\textbf{Atributos}
El software debe proveer la funcionalidad y desempeño requeridos por el usuario y
debe ser mantenible, confiable, eficiente y aceptable.
\begin{itemize}
    \item \textbf{Mantenible:} El software debe poder evolucionar.
    \item \textbf{Confiable:} No debe causar daños económicos o físicos.
    \item \textbf{Eficiente:} No desperdiciar recursos del sistema.
    \item \textbf{Aceptable:} Los usuarios deben de aceptarlo.
    \item Debe ser entendible, utilizable y compatible con otros sistemas.
\end{itemize}
\subsubsection{Importancia y aplicación del software}
\textbf{Importancia del Software}\\

Cada software desarrolla funciones específicas dentro de una diversa gama de aplicaciones, 
y sin duda alguna uno de los programas que mayor utilidad representa dentro de una empresa, 
son los denominados Sistemas de Soporte a la Decisión (DSS).

De esta manera, la toma de decisiones se convierte en una variable crítica de éxito dentro 
de las empresas, y es aquí donde radica la importancia de un DSS. \\ \\
\textbf{Aplicaciones del Software}\\

El software puede aplicarse en cualquier situación en la que se haya definido previamente 
un conjunto específico de pasos procedimentales.

El contenido y el determinismo de la información son factores importantes a considerar 
para determinar la naturaleza de una aplicación de software. El contenido se refiere al 
significado y a la forma de la información de entrada y salida. El determinismo de la 
información se refiere a la predictibilidad del orden y del tiempo de llegada de los datos.

Las siguientes áreas del software indican la amplitud de las aplicaciones potenciales:
\begin{itemize}
    \item \textbf{ Software de sistemas:} es un conjunto de programas que han sido escritos 
    para servir a otros programas.\\
    Algunos programas de sistemas (por ejemplo: compiladores, editores y utilidades de gestión 
    de archivos) procesan estructuras de información complejas pero determinadas.
    \item \textbf{ Software de tiempo real:}  coordina, analiza, controla sucesos del mundo 
    real conforme ocurren, se denomina de tiempo real.
    \item \textbf{ Software de gestión:} Las aplicaciones en esta área re estructuran los datos 
    existentes para facilitar las operaciones comerciales o gestionar la toma de decisiones. \\
    Además de las tareas convencionales de procesamientos de datos, las aplicaciones de software 
    de gestión también realizan cálculo interactivo (por ejemplo: el procesamiento de transacciones 
    en puntos de ventas).
    \item \textbf{ Software de ingeniería y científico:} está caracterizado por los algoritmos 
    de manejo de números. Las aplicaciones van desde la astronomía a la vulcanología, 
    desde el análisis de la presión de los automotores a la dinámica orbital de las 
    lanzaderas espaciales y desde la biología molecular a la fabricación automática.
    \item \textbf{ Software empotrado:} reside en memoria de sólo lectura y se
    utiliza para controlar productos y sistemas de los mercados industriales y de consumo. El
    software empotrado puede ejecutar funciones muy limitadas y curiosas (por ejemplo: el
    control de las teclas de un horno de microondas) o suministrar una función significativa y
    con capacidad de control (por ejemplo: funciones digitales en un automóvil, tales como
    control de la gasolina, indicadores en el salpicadero, sistemas de frenado, etc.).
    \item \textbf{ Sodtware de computadoras personales:} . El
    procesamiento de textos, las hojas de cálculo, los gráficos por computadora, multimedia,
    entretenimientos, gestión de bases de datos, etc.
    \item \textbf{ Software basado en Web:} Las páginas Web buscadas por un explorador son 
    software que incorpora instrucciones ejecutables y datos.
    \item \textbf{ Software de inteligencia artificial:} hace uso de algoritmos no
    numéricos para resolver problemas complejos para los que no son
    adecuados el cálculo o el análisis directo.
\end{itemize}
\subsubsection{Ciclo de vida del software}
Un marco de referencia que contiene los procesos, las actividades y las
tareas involucradas en el desarrollo, la explotación y el mantenimiento de un
producto de software, abarcando la vida del sistema desde la definición de
los requisitos hasta la finalización de su uso.\\
\subsubsection{Modelos de procesos}
\textbf{¿Qué es un modelo de proceso de software?}\\
Representación formal y simplificada de un proceso de software, presentada desde una 
perspectiva específica.\\
Ejemplos de perspectiva del proceso del hardware.
\begin{itemize}
    \item Flujo de trabajo, secuencia de actividades.
    \item Flujo de datos, flujo de la información.
    \item Rol/acción, quien realiza qué.
\end{itemize}
\textbf{Modelos genéricos}
\begin{enumerate}
    \item \textbf{Lineal secuencial:} sugiere un enfoque sistemático, secuencial, para el
    desarrollo del software. Comprende el análisis, diseño, codificación, pruebas y mantenimiento.
    \item \textbf{Cascada:} Tiene las mismas características que el modelo lineal como se había 
    mencionado anteriormente pero en este se tiene la capacidad de regresar si se detecta un error 
    en cualquiera de las etapas de planeación, desarrollo, diseño, pruebas y mantenimiento del 
    software.
    \item \textbf{Incremental:} El modelo incremental combina elementos del modelo lineal 
    secuencial con la filosofía interactiva de construcción de prototipos. El software se ve como 
    una integración de resultados sucesivos obtenidos después de cada interacción
    \item \textbf{Desarrollo rápido de aplicaciones:} es un modelo de proceso del
    desarrollo del software lineal secuencial que enfatiza un ciclo de desarrollo
    extremadamente corto.

    El modelo DRA es una adaptación a alta velocidad del modelo lineal secuencial en el que se 
    logra el desarrollo rápido utilizando una construcción basada en componentes.    
    \item \textbf{Prototipos:}Comienza con la recolección de requisitos. El desarrollador y el 
    cliente encuentran y definen los objetivos globales para el software, identifican los 
    requisitos conocidos y las áreas del esquema en donde es obligatoria más definición.

    El prototipo lo evalúa el cliente/usuario y se utiliza para refinar los requisitos del software 
    a desarrollar. La iteración ocurre cuando el prototipo se pone a punto para satisfacer las 
    necesidades del cliente, permitiendo al mismo tiempo que el desarrollador comprenda mejor lo 
    que se necesita hacer.
    \item \textbf{Esprial:} La meta del modelo espiral del proceso de producción del software es proporcionar un marco para
    diseñar tales procesos.
    \item \textbf{Basados en componentes:} asume que partes del sistema ya existen y se enfoca 
    a su integración.
\end{enumerate}


\subsection{Proceso de gesti\'on de proyecto}
\subsubsection{Ámbito del software}
El ámbito del software describe el control y los datos a procesar, la función, el rendimiento, 
las restricciones, las interfaces y la fiabilidad; Se evalúan las funciones 
descritas en la declaración del ámbito, y en algunos casos se refinan para dar más 
detalles antes del comienzo de la estimación.

Dado que las estimaciones del coste y de la planificación temporal están orientadas a 
la función, muchas veces es útil llegar a un cierto grado de descomposición. Las 
consideraciones de rendimiento abarcan los requisitos de tiempo de respuesta y de procesamiento.\\
\subsubsection{Estudio de factibilidad}
Los autores Putnam y Myers tratan este aspecto cuando escriben que: no todo lo imaginable es factible ni siquiera en
el software.\\
La factibilidad del software tiene cuatro dimensiones sólidas:
\begin{itemize}
    \item Tecnología ¿Es factible un proyecto técnicamente? ¿Está dentro del estado 
    actual de la técnica?. 
    \item Financiamiento ¿Es factible financieramente? ¿Puede realizarse a un coste 
    asumible por la empresa de software y por el cliente?
    \item Tiempo ¿Pueden los proyectos adelantarse a los de la competencia?
    \item Recursos ¿La organización cuenta con los recursos suficientes para tener 
    éxito?
\end{itemize}
La respuesta es sencilla depende de la experiencia, ya que puede que se haya hecho 
antes algún proyecto de este tipo o puede que no se tenga experiencia en el proyecto y 
por lo tanto no son fáciles.\\
\subsubsection{Análisis de riesgo}
El riesgo se mide por el grado de incertidumbre en las estimaciones cuantitativas establecidas 
por recursos, coste y planificación temporal. Si no se entiende bien el 
ámbito del proyecto o los requisitos del proyecto están sujetos a cambios, la 
incertidumbre y el riesgo son peligrosamente altos.

Lo que es más importante, el cliente y el panificador, deben tener presente que 
cualquier cambio en los requisitos del software significa inestabilidad en el coste 
y en la planificación temporal.\\
\subsubsection{Recursos}
La segunda tarea de la planificación del desarrollo de software es la estimación de 
los recursos requeridos para acometer el esfuerzo de desarrollo de software.\\
Cada recurso queda especificado mediante cuatro características:

Descripción del recurso, informe de disponibilidad, fecha cronológica en la que se
requiere el recurso, tiempo durante el que será aplicado el recurso.
\subsubsection{Estimación}
La estimación del coste y del esfuerzo del software nunca será una ciencia exacta, 
son demasiadas las variables humanas, técnicas, de entorno, políticas que pueden 
afectar al coste final del software y al esfuerzo aplicado para desarrollarlo.
\subsubsection{Planificación del proyecto}
La planificación temporal de un proyecto de software es una actividad que distribuye 
el esfuerzo estimado a lo largo de la duración prevista del proyecto, asignando el 
esfuerzo a las tareas específicas de la ingeniería del software.

La planificación temporal identifica las principales actividades de la ingeniería de 
software y las funciones del producto a las que se aplican, se identifican y 
programan las tareas del software especificas (requeridas para realizar una actividad).

\begin{itemize}
    \item Calendario de actividades: Designa la programación predeterminada de los 
    trabajos para todos los recursos asignados al proyecto. Puede establecer el 
    calendario del proyecto para indicar un periodo no laborable (como los días 
    festivos de la organización).
    \item Diagrama de Gantt: Gráfica de Gantt o carta Gantt es una herramienta que 
    permite modelar la planificación de las tareas necesarias para la realización de 
    un proyecto, cuyo objetivo es mostrar el tiempo de dedicación previsto para 
    diferentes tareas o actividades a lo largo de un tiempo total determinado. 
    \item Diagrama de Pert: PERT es básicamente un método para analizar las tareas 
    involucradas en completar un proyecto dado, especialmente el tiempo para completar 
    cada tarea, e identificar el tiempo mínimo necesario para completar el proyecto 
    total.
    
    La parte más famosa de PERT son las Redes PERT, diagramas de líneas de tiempo que 
    se interconectan. PERT está diseñado para proyectos de gran escala, que se 
    ejecutan de una vez, complejos y no rutinarios.
\end{itemize} 


\subsubsection{Supervisión y control del plan del proyecto}
Al frente de este equipo se situará un director o jefe del proyecto, que será el 
último responsable de la coordinación del equipo de gestión, y de todos las 
partes involucradas en el proyecto, así como del control de las actividades, tareas, 
costes, uso de los recursos… Para poder llevar a cabo estas tareas, es necesario
disponer de una correcta programación, así como de las herramientas adecuadas de 
control.\\ \\
\subsection{Metodolog\'ias}
\subsubsection{Metodologías estructuradas}
Son metodologías que se basan en la descomposición de un problema en funciones.\\
Las metodologías estructuradas se dividen en:
\begin{itemize}
    \item Metodologías orientadas a procesos.
    \item Metodologías orientadas a datos.
    \item Metdologías mixtas.
\end{itemize}
\textbf{Merise}
Las metodología Merise fue desarrollada en 1977 por el ministerio de industria francés.
La base de Merise comenzó en 1972 en la universidad de Aix en Provence.
Esta metodología esta integrada por: Análisis, Concepción y Gestión de proyectos.
La metodología esta conformada por 4 fases:
\begin{enumerate}
    \item Estudio preliminar: Análisis de la situación.
    Propuesta de solución global (gestión, organización, decisiones del comité y directivo).
    \item Estudio detallado: Análisis del sistema realizar estudios técnicos y presupuestos.
    \item Implementación:Solución en un lenguaje de programación.
    Evaluación de hardware y software.
    Pruebas.
    \item Realización y puesta en marcha: Instalación del sistema desarrollado.
    Organización del personal por áreas.
\end{enumerate}
\textbf{Yourdon}
Esta metodología involucra análisis, desarrollo del diseño y mejora en la medición de la calidad 
del diseño de software.\\
\textbf{Gane-Sarson}
La métrica Gane Sarson se comienza a utilizar en 1977.\\
Esta métrica es el resultado de varios años de práctica en la consultoría de análisis y diseño 
estructurado.\\
Es creada por la empresa MCAUTO/IST bajo el nombre de STRADIS SDM.\\
Para el uso y desempeño de esta metodología se utilizan los siguientes 5 pasos:
\begin{enumerate}
    \item Construir un modelo lógico en curso.
    \item Construir un modelo lógico del nuevo sistema lo cual involucra:
    
    Diagramas de flujo de datos, Diccionario de datos, y especificaciones de los procesos.

    También construir un modelo de datos que exprese en 3era forma normal (3FN) los datos
    almacenados.
    \item Diseñar físicamente la BD.
    \item Crear un nuevo modelo físico del sistema.
    \item Empaquetar la especificación en subsistemas. 
\end{enumerate}
\subsubsection{Metodologías Orientadas a objetos}
El modelado Orientado a Objetos es una forma de pensar y solucionar problemas usando 
modelos del mundo real.

Para ello se utilizan objetos que combinan estructuras de datos y comportamientos en 
una unidad simple (clases con atributos y métodos).

Las metodologías OO se dividen en: “revolucionarias o puras” y “sintetistas o 
evolutivas”.\\ \\
\textbf{OMT}\\
La metodología OMT (Técnica de Modelado de Objetos) es desarrollada por James 
Rumbaugh y sus colaboradores de General Electric en 1991.\\
Es una metodología que en su momento gozo de mucho prestigio para el desarrollo de 
sistemas dentro de la industria.\\ \\

\textbf{Ingeniería de Software Orientado a Objetos}\\
Esta metodología es creada por Ivar Jacobson en 1992, la ingeniería de software orientado a objetos por su
abreviatura se conoce como OOSE.\\ \\

\textbf{Proceso unificado}\\
El Proceso Unificado es un proceso de desarrollo de software definido como:
“Conjunto de actividades necesarias para transformar los requisitos del usuario en 
un sistema software”.\\
\subsubsection{Proceso unificado racional}
Para el proceso unificado de Rational o RUP tenemos que incluimos lo anteriormente 
visto para el proceso unificado pero se complementa lo siguiente:\\
El ciclo de vida de esta metodología es la misma que el proceso unificado pero sus 
iteraciones se realizan bajo algo conocido como disciplinas.\\
Las disciplinas pueden ser de dos tipos:

\begin{itemize}
    \item Disciplinas de desarrollo que están formadas por:
    \begin{itemize}
        \item Ingeniería de negocios.
        \item Requerimientos.
        \item Análisis y diseño.
        \item Implementación.
        \item Pruebas.
    \end{itemize}
    \item Disciplinas de soporte.
    \begin{itemize}
        \item Configuración y administración del cambio (versiones del proyecto).
        \item Administrando horarios y recursos del proyecto.
        \item Administrando ambiente de desarrollo.
        \item Distribución del proyecto.
    \end{itemize}
\end{itemize}

\textbf{Metodologías agiles}\\
El punto de partida fue el Manifiesto Ágil, un documento que resume la filosofía ágil 
del desarrollo de software.\\
El manifiesto ágil consta de 4 puntos:
\begin{itemize}
    \item Elegir primero el equipo de desarrolladores que el entorno en el que se va 
    a desarrollar.
    \item Desarrollar software más funcional que una buena documentación.
    \item El cliente forma parte del equipo de desarrollo.
    \item La planificación del software es flexible y abierta para su fácil 
    modificación.
\end{itemize}
\textbf{Programación extrema}\\
Creada por Kent Beck famoso ingeniero de software estadounidense y participante del 
manifiesto ágil.\\
Esta metodología es conocida como Extreme Programming o XP.\\
Es la práctica mas utilizada para la creación de software cuando se dispone de un 
proyecto y equipos pequeños y el plazo de entrega es demasiado limitado.\\ \\
\textbf{SCRUM}\\
Desarrollada por Ken Schwaber, Jeff Sutherland y Mike Beedle.\\
Está especialmente indicada para proyectos con un rápido cambio de requisitos.\\
El desarrollo de software se realiza mediante iteraciones, denominadas sprints, con 
una duración de 30 días.\\
El resultado de cada sprint es un incremento ejecutable que se muestra al cliente.\\
Se requiere una reunión diaria de 15 minutos del equipo de desarrollo para 
coordinación e integración.\\ \\
\textbf{Otras metodologías}
\begin{itemize}
    \item Crystal Methodologies.
    \item Dynamic Systems Development Method (DSDM).
    \item Adaptative Software
\end{itemize}



%\subsection{Calidad y normas de calidad}
%\subsection{Modelos de madurez}
%\subsection{Temas selectos}

%\subsection{}
%Programacion reactiva
%Metodologias agiles y scrum
\end{document}